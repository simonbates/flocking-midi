/*
 * Flocking MIDI Core Sender/Receiver
 * http://github.com/colinbdclark/flocking-midi
 *
 * Copyright 2014-2016, Colin Clark
 * Licensed under the MIT license.
 */

"use strict";

var fluid = fluid || require("infusion"),
    flock = fluid.registerNamespace("flock");

/**
 * An "abstract" grade that the defines invokers for sending MIDI messages.
 */
fluid.defaults("flock.midi.sender", {
    gradeNames: "fluid.component",

    invokers: {
        sendRaw: {
            func: "{that}.events.onSendRaw.fire"
        },

        send: {
            funcName: "flock.midi.sender.send"
        }
    },

    events: {
        onSendRaw: null
    }
});

flock.midi.sender.send = function () {
    flock.fail("Sending MIDI messages is not currently supported.");
};


/**
 * An "abstract" grade that the defines the event names
 * for receiving MIDI messages
 */
fluid.defaults("flock.midi.receiver", {
    gradeNames: ["fluid.component"],

    events: {
        raw: null,
        message: null,
        note: null,
        noteOn: null,
        noteOff: null,
        control: null,
        program: null,
        aftertouch: null,
        pitchbend: null
    },

    listeners: {
        "raw.fireSpecificMIDIMessageEvent": {
            funcName: "flock.midi.receiver.fireMIDIMessageEvent",
            args: ["{arguments}.0", "{that}.events"]
        }
    }
});

flock.midi.receiver.fireMIDIMessageEvent = function (midiEvent, events) {
    var midiSpec = flock.midi.read(midiEvent.data),
        eventForType = midiSpec.type ? events[midiSpec.type] : undefined;

    events.message.fire(midiSpec, midiEvent);

    // TODO: Is it necessary to have a generic event for all note events?
    // Does anyone use this in the wild?
    if (midiSpec.type === "noteOn" || midiSpec.type === "noteOff") {
        events.note.fire(midiSpec, midiEvent);
    }

    if (eventForType) {
        eventForType.fire(midiSpec, midiEvent);
    }
};
