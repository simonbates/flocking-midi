/*
 * Flocking MIDI Core Readers
 * http://github.com/colinbdclark/flocking-midi
 *
 * Copyright 2014-2016, Colin Clark
 * Licensed under the MIT license.
 */

"use strict";

var fluid = fluid || require("infusion"),
    flock = fluid.registerNamespace("flock");

fluid.registerNamespace("flock.midi");

flock.midi.read = function (data) {
    var status = data[0],
        type = status >> 4,
        chan = status & 0xf,
        fn;

    switch (type) {
    case 8:
        fn = flock.midi.read.noteOff;
        break;
    case 9:
        fn = flock.midi.read.dispatchNoteOn;
        break;
    case 10:
        fn = flock.midi.read.polyAftertouch;
        break;
    case 11:
        fn = flock.midi.read.controlChange;
        break;
    case 12:
        fn = flock.midi.read.programChange;
        break;
    case 13:
        fn = flock.midi.read.channelAftertouch;
        break;
    case 14:
        fn = flock.midi.read.pitchbend;
        break;
    case 15:
        fn = flock.midi.read.system;
        break;
    default:
        fn = flock.midi.failUnrecognizedMessage;
    }

    return fn(chan, data);
};

flock.midi.failUnrecognizedMessage = function (data) {
    return flock.fail("Received an unrecognized MIDI message: " +
        fluid.prettyPrintJSON(data));
};

flock.midi.read.dispatchNoteOn = function (chan, data) {
    // A note on message with a velocity of 0 is actually a note off.
    var type = data[2] === 0 ? "noteOff" : "noteOn";
    return flock.midi.read.note(type, chan, data);
};

flock.midi.read.note = function (type, chan, data) {
    return {
        type: type,
        chan: chan,
        note: data[1],
        velocity: data[2]
    };
};

flock.midi.read.noteOn = function (chan, data) {
    return flock.midi.read.note("noteOn", chan, data);
};

flock.midi.read.noteOff = function (chan, data) {
    return flock.midi.read.note("noteOff", chan, data);
};

flock.midi.read.polyAftertouch = function (chan, data) {
    return {
        type: "aftertouch",
        chan: chan,
        note: data[1],
        pressure: data[2]
    };
};

flock.midi.read.controlChange = function (chan, data) {
    return {
        type: "control",
        chan: chan,
        number: data[1],
        value: data[2]
    };
};

flock.midi.read.programChange = function (chan, data) {
    return {
        type: "program",
        chan: chan,
        program: data[1]
    };
};

flock.midi.read.channelAftertouch = function (chan, data) {
    return {
        type: "aftertouch",
        chan: chan,
        pressure: data[1]
    };
};

flock.midi.read.twoByteValue = function (data) {
    return (data[2] << 7) | data[1];
};

flock.midi.read.pitchbend = function (chan, data) {
    return {
        type: "pitchbend",
        chan: chan,
        value: flock.midi.read.twoByteValue(data)
    };
};

flock.midi.read.system = function (status, data) {
    var fn;
    switch (status) {
    case 0:
        fn = flock.midi.read.sysex;
        break;
    case 1:
        fn = flock.midi.read.quarterFrameMTC;
        break;
    case 2:
        fn = flock.midi.read.songPointer;
        break;
    case 3:
        fn = flock.midi.read.songSelect;
        break;
    case 6:
        fn = flock.midi.read.tuneRequest;
        break;
    case 8:
        fn = flock.midi.read.clock;
        break;
    case 10:
        fn = flock.midi.read.start;
        break;
    case 11:
        fn = flock.midi.read["continue"];
        break;
    case 12:
        fn = flock.midi.read.stop;
        break;
    case 14:
        fn = flock.midi.read.activeSense;
        break;
    case 15:
        fn = flock.midi.read.reset;
        break;
    default:
        fn = flock.midi.failUnrecognizedMessage;
    }

    return fn(data);
};

flock.midi.failUnsupportedMessage = function (type) {
    flock.fail("Flocking does not currently support MIDI " + type + " messages.");
    return;
};

flock.midi.read.quarterFrameMTC = function () {
    return flock.midi.failUnsupportedMessage("quarter frame MTC");
};

flock.midi.read.sysex = function (data) {
    return {
        type: "sysex",
        data: data
    };
};

flock.midi.read.valueMessage = function (type, value) {
    return {
        type: type,
        value: value
    };
};

flock.midi.read.songPointer = function (data) {
    var val = flock.midi.read.twoByteValue(data);
    return flock.midi.read.valueMessage("songPointer", val);
};

flock.midi.read.songSelect = function (data) {
    return flock.midi.read.valueMessage("songSelect", data[1]);
};

flock.midi.read.tuneRequest = function () {
    return {
        type: "tuneRequest"
    };
};

flock.midi.systemRealtimeMessages = [
    "tuneRequest",
    "clock",
    "start",
    "continue",
    "stop",
    "activeSense",
    "reset"
];

flock.midi.createSystemRealtimeMessageReaders = function (systemRealtimeMessages) {
    fluid.each(systemRealtimeMessages, function (type) {
        flock.midi.read[type] = function () {
            return {
                type: type
            };
        };
    });

};

flock.midi.createSystemRealtimeMessageReaders(flock.midi.systemRealtimeMessages);
