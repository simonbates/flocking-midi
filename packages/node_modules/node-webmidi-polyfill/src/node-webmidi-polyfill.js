/*
 * Flocking Web MIDI Polyfill for Node.js
 * http://github.com/colinbdclark/flocking-midi
 *
 * Copyright 2014-2016, Colin Clark
 * Licensed under the MIT license.
 */

/*global Promise*/

"use strict";

var midi = require("midi");

/**
 * MIDIAccess represents access to the midi system.
 * @constructor
 */
var MIDIAccess = function (options) {
    options = options || {
        sysex: false
    };

    this.input = new midi.input();
    this.output = new midi.output();

    // TODO: Implement onstatechange via polling.

    this.input.ignoreTypes(!options.sysex, false, false);
    this.sysexEnabled = options.sysex;
};

var p = MIDIAccess.prototype = {};
p.constructor = MIDIAccess;

p.inputs = function () {
    return MIDIAccess.getAllPorts("input", this.input);
};

p.outputs = function () {
    return MIDIAccess.getAllPorts("output", this.output);
};

// TODO: To follow spec, the inputs and outputs structures
// need to be map-likes of type MIDIInputMap and MIDIOutputMap
MIDIAccess.getAllPorts = function (type, midi) {
    var numPorts = midi.getPortCount(),
        ports = new Array(numPorts);

    for (var i = 0; i < numPorts; i++) {
        ports[i] = new MIDIPort(type, i);
    }

    return ports;
};


/**
 * MIDIPort represents a MIDI input or output port.
 * @constructor
 */
var MIDIPort = function (type, portNum) {
    this.type = type;
    this.midi = new midi[this.type]();
    this.id = portNum;
    this.name = this.midi.getPortName(this.id);
    this.listeners = {};
    this.state = "connected";
    this.connection = "closed";

    // TODO: Implement onstatechange,
    // including support for updating disconnected ports.

    // TODO: Implement onmidimessage event assignment.
};

p = MIDIPort.prototype = {};
p.constructor = MIDIPort;

p.addEventListener = function (evtName, fn) {
    MIDIPort.throwIfNotMIDIMessage(evtName);
    this.midi.on("message", MIDIPort.wrapMessageListener(this, fn));
};

p.removeEventListener = function (evtName, fn) {
    MIDIPort.throwIfNotMIDIMessage(evtName);
    var guid = fn.__flock_midi_listener_id,
        wrapper = this.listeners[guid];

    if (wrapper) {
        this.midi.removeListener("message", wrapper);
        this.listeners[guid] = undefined;
    }
};

p.open = function () {
    this.midi.openPort(this.id);
    this.connection = "open";
};

p.send = function (data) {
    if (this.type !== "output") {
        throw new Error("An input port can't be used to send MIDI messages.");
    }

    this.midi.sendMessage(data);
};

p.clear = function () { /* Implemented as a no-op. */};

p.close = function () {
    this.midi.closePort();
    this.connection = "closed";
};

MIDIPort.throwIfNotMIDIMessage = function (evtName) {
    if (evtName !== "midimessage") {
        throw new Error("Port.addListener() only supports the midimessage event.");
    }
};

MIDIPort.listenerID = 0;
MIDIPort.allocateListenerID = function (/* listeners */) {
    var guid = "flock-guid-" + MIDIPort.listenerID++;
    fluid.each(arguments, function (arg) {
        arg.__flock_midi_listener_id = guid;
    });

    return guid;
};

MIDIPort.wrapMessageListener = function (that, fn) {
    var wrapper = function (deltaTime, data) {
        var e = {
            timeStamp: deltaTime,
            data: data
        };

        fn(e);
    };

    var guid = MIDIPort.allocateListenerID(fn, wrapper);
    that.listeners[guid] = wrapper;

    return wrapper;
};

var requestMIDIAccess = function (options) {
    var p = new Promise(function (resolve, reject) {
        try {
            var access = new MIDIAccess(options);
            resolve(access);
        } catch (err) {
            reject(err);
        }
    });

    return p;
};

module.exports = {
    requestMIDIAccess: requestMIDIAccess,
    MIDIAccess: MIDIAccess,
    MIDIPort: MIDIPort
};
