/*
 * Flocking MIDI Web MIDI System
 * http://github.com/colinbdclark/flocking-midi
 *
 * Copyright 2014-2016, Colin Clark
 * Licensed under the MIT license.
 */

"use strict";

var fluid = fluid || require("infusion");

fluid.makeGradeLinkage("flock.midi.web.systemLinker",
    ["flock.midi.system"], "flock.midi.web.system");

/**
 * A MIDI System component represents a system of MIDI device ports
 */
fluid.defaults("flock.midi.web.system", {
    gradeNames: "flock.midi.system",

    sysex: false,

    portTypeModelMap: {
        "input": "inputs",
        "output": "outputs"
    },

    components: {
        access: {
            type: "flock.midi.web.access",
            options: {
                sysex: "{system}.options.sysex"
            }
        }
    },

    invokers: {
        modelizePorts: {
            funcName: "flock.midi.web.system.modelizePorts",
            args: ["{arguments}.0", "{that}.events.afterPortsModelized.fire"]
        }
    },

    events: {
        onPortChange: "{access}.events.onPortChange"
    },

    listeners: {
        "onPortChange.updatePort": {
            funcName: "flock.midi.web.system.updatePort",
            args: ["{arguments}.0", "{that}.applier", "{that}.options.portTypeModelMap"]
        },

        "onRefreshPorts.updatePorts": {
            funcName: "flock.midi.web.system.refreshPorts",
            args: ["{that}"]
        }
    }
});

/**
 * Converts a WebMIDI Port Object into a model object.
 *
 * @param {MIDIPort} a MIDIInput or MIDIOutput object to convert
 * @return {Object} a model object representing the port
 */
flock.midi.web.system.modelizePort = function (port) {
    return {
        type: port.type,
        id: port.id,
        name: port.name,
        manufacturer: port.manufacturer,
        state: port.state,
        connection: port.connection
    };
};

flock.midi.web.system.modelizePortsOfType = function (ports, portsModel) {
    ports.forEach(function (port) {
        portsModel[port.id] = flock.midi.web.system.modelizePort(port);
    });

    return portsModel;
};

/**
 * Converts a Web MIDI Access object's ports into a format compatible with
 * the Infusion ChangeApplier.
 *
 * @param {MIDIPortMap} ports a WebMIDI MIDIInputMap or MIDIOutputMap object
 * @return {Object} a modelized structure representing the ports
 */
flock.midi.web.system.modelizePorts = function (access, afterPortsModelized) {
    var portsModel = {};

    flock.midi.web.system.modelizePortsOfType(access.inputs, portsModel);
    flock.midi.web.system.modelizePortsOfType(access.inputs, portsModel);
    afterPortsModelized(portsModel);

    return portsModel;
};

// Unsupported, non-API function.
flock.midi.web.system.updatePort = function (port, applier) {
    var pathSegs = ["ports", port.id];

    if (port.state === "disconnected") {
        applier.change(pathSegs, undefined, "DELETE");
        return;
    }

    var portModel = flock.midi.web.system.modelizePort(port);
    applier.change(pathSegs, portModel);
};

flock.midi.web.system.refreshPorts = function (that) {
    that.refreshPorts(that.access.access);
};
