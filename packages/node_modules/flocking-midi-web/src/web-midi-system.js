/*
 * Flocking MIDI Web MIDI System
 * http://github.com/colinbdclark/flocking-midi
 *
 * Copyright 2014-2016, Colin Clark
 * Licensed under the MIT license.
 */

"use strict";

var fluid = fluid || require("infusion");

fluid.makeGradeLinkage("flock.midi.web.systemLinker",
    ["flock.midi.system"], "flock.midi.web.system");

/**
 * A MIDI System component represents a system of MIDI device ports
 */
fluid.defaults("flock.midi.web.system", {
    gradeNames: "flock.midi.system",

    sysex: false,

    model: {
        inputs: {},
        outputs: {}
    },

    components: {
        access: {
            type: "flock.midi.web.access",
            options: {
                sysex: "{system}.options.sysex"
            }
        }
    },

    events: {
        onPortChange: "{access}.events.onPortChange"
    },

    listeners: {
        "onReady.updatePorts": {
            funcName: "flock.midi.web.system.updatePorts",
            args: ["{arguments}.0", "{that}.applier"]
        },

        "onPortChange.updatePort": {
            funcName: "flock.midi.web.system.updatePort",
            args: ["{arguments}.0", "{that}.applier", "{that}.options.portTypeModelMap"]
        }
    },

    portTypeModelMap: {
        "input": "inputs",
        "output": "outputs"
    }
});

/**
 * Converts a Web MIDI Access object's ports into a format compatible with
 * the Infusion ChangeApplier.
 *
 * @param {MIDIPortMap} ports a WebMIDI MIDIInputMap or MIDIOutputMap object
 * @return {Object} a modelized structure representing the ports
 */
flock.midi.web.system.modelizePorts = function (ports) {
    var collected = {};

    ports.forEach(function (port) {
        collected[port.id] = flock.midi.web.system.modelizePort(port);
    });

    return collected;
};

/**
 * Converts a WebMIDI Port Object into a model object.
 *
 * @param {MIDIPort} a MIDIInput or MIDIOutput object to convert
 * @return {Object} a model object representing the port
 */
flock.midi.web.system.modelizePort = function (port) {
    return {
        type: port.type,
        id: port.id,
        name: port.name,
        manufacturer: port.manufacturer,
        state: port.state,
        connection: port.connection
    };
};

// Unsupported, non-API function.
flock.midi.web.system.updatePorts = function (access, applier) {
    var updatedModel = {
        inputs: flock.midi.web.system.modelizePorts(access.inputs),
        outputs: flock.midi.web.system.modelizePorts(access.outputs)
    };

    applier.change("", updatedModel);
};

// Unsupported, non-API function.
flock.midi.web.system.updatePort = function (port, applier, portTypeModelMap) {
    var headSeg = portTypeModelMap[port.type],
        pathSegs = [headSeg, port.id];

    if (port.state === "disconnected") {
        applier.change([headSeg, port.id], undefined, "DELETE");
        return;
    }

    var portModel = flock.midi.web.system.modelizePort(port);
    applier.change(pathSegs, portModel);
};
